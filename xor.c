/*Program written by Tiffani Shilts Winter 2020. This program is c99 compliant.
  xor: This program accepts user input via argv, and read(). User is allowed to provide: -i input preference (either
  stdin or file), -o output preference (either stdout or file), and <string> character mask. User must provide mask
  of 10 characters or less at runtime. A string of characters to mask is acquired via preferred method. Character
  string is xor'd with provided mask and output to user's preferred method. Default options generated by the program
  if the user does not specify are: stdin for input, and stdout for output. Program uses only syscalls for all user
  input and output.
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

int main (int argc, char *argv[])
{
    // comparator for argv flags
    char inputComparator[] = "-i";
    char outputComparator[] = "-o";

    // file handling comparison
    char comparisonStringIn[] = "stdin";
    char comparisonStringOut[] = "stdout";

    //fd in & out
    int fileDescIn;
    int fileDescOut;

    // read int
    int numBytes;

    // buffer for read input
    char *buffer = (char*)calloc(10001, sizeof(char));
    if(!buffer)
    {
        write(STDERR_FILENO, "Could not create buffer...exiting\n", 35);
        exit(1);
    }

    // input file array
    char* i = malloc(sizeof(char) * 1001);
    if (!i)
    {
        write(STDERR_FILENO, "Could not create Input File...exiting\n", 39);
        exit(1);
    }
    i = "stdin";

    // output file array
    char* o = malloc(sizeof(char) * 1001);
    if (!o)
    {
        write(STDERR_FILENO, "Could not create Output File...exiting\n", 40);
        exit(1);
    }
    o = "stdout";

    // array for user mask input
    char* mask = (char*)calloc(11, sizeof(char));
    if(!mask)
    {
        write(STDERR_FILENO, "Could not create mask...exiting\n", 33);
        exit(1);
    }

    // search argv for mask
    for(int j = 1; j < argc; j++)
    {
        if((strcmp(inputComparator, argv[j]) != 0) && (strcmp(outputComparator, argv[j]) != 0) && (strcmp(inputComparator, argv[(j - 1)]) != 0)
           && (strcmp(outputComparator, argv[(j - 1)]) != 0))
        {
            strcpy(mask, argv[j]);
        }
    }

    // search argv for flag specifiers
    for(int j = 0; j < argc; j++)
    {
        if(strcmp(inputComparator, argv[j]) == 0)
        {
            i = argv[j+1];
        }
        else if(strcmp(outputComparator, argv[j]) == 0)
        {
            o = argv[j+1];
        }
    }

    // file has been entered by user
    if((strcmp(comparisonStringIn, i)) != 0)
    {
        fileDescIn = open(i, O_RDONLY);

        if (fileDescIn < 0)
        {
            write(STDERR_FILENO, "Could not open input file...exiting\n", 37);
            exit(1);
        }
    }

    // if user requests no file entry or does not specify
    if((strcmp(comparisonStringIn, i)) == 0)
    {
        fileDescIn = 0;     //STDIN
    }

    // file has been entered by user
    if((strcmp(comparisonStringOut, o)) != 0)
    {
        fileDescOut = open(o, O_WRONLY);

        if (fileDescOut < 0)
        {
            write(STDERR_FILENO, "Could not open output file...exiting\n", 38);
            exit(1);
        }
    }

    // if user requests no file entry or does not specify
    if((strcmp(comparisonStringOut, o)) == 0)
    {
        fileDescOut = 1;        //STDOUT
    }

    free(i);
    free(o);

    // encouragement
    if (fileDescIn != 0)
    {
        write(1, "Success! Reading file...\n", 24);
    }

    // user provides string of characters to reverse
    if(fileDescIn == 0)
    {
        write(1, "Please enter a string of letters. Press ENTER when finished.\n", 62);
    }
    // read input and store in buffer
    while((numBytes = read(fileDescIn, buffer, 10000)) > 0)
        close(fileDescIn);

    // append null terminator
    buffer[strlen(buffer) - 2] = '\0';

    // allocate arrays for extended mask and xor results array
    char* xorMask = (char*)calloc(10001, sizeof(char));
    if(!xorMask)
    {
        write(STDERR_FILENO, "Could not create xor mask...exiting\n", 37);
        exit(1);
    }

    char* results = (char*)calloc(10001, sizeof(char));
    if(!results)
    {
        write(STDERR_FILENO, "Could not create result storage...exiting\n", 43);
        exit(1);
    }

    // copy original mask to first indices in order to duplicate
    strcpy(xorMask, mask);

    // start of mask copy
    int maskIndex = strlen(mask);
    // iterations needed after first mask
    int iterations = strlen(buffer) - strlen(mask);
    if(strlen(mask) < strlen(buffer))
    {
        for(int j = 0; j < iterations; j++)
        {
            xorMask[maskIndex++] = xorMask[j];
        }
    }

    // truncate mask if longer than string
    int sizeDiff;
    if(strlen(mask) > strlen(buffer))
    {
        sizeDiff = strlen(mask) - strlen(buffer);
        xorMask[strlen(xorMask) - sizeDiff] = '\0';
    }

    free(mask);

    // xor
    for(int j = 0; j < strlen(buffer); j++)
    {
        results[j] = buffer[j]^xorMask[j];
    }

    free(xorMask);

    // creating char* for printing
    char** printArray = malloc(strlen(results) * sizeof(char*));
    if(!printArray)
    {
        write(STDERR_FILENO, "Could not print...exiting\n", 27);
        exit(1);
    }

    for(int j = 0; j < strlen(results); j++)
    {
        printArray[j] = calloc(2, sizeof(char));
        if(!printArray[j])
        {
            write(STDERR_FILENO, "Could not print...exiting\n", 27);
            exit(1);
        }
        printArray[j][0] = results[j];
    }

    free(results);

    // print results
    char tempPrintArray[2];
    for(int j = 0; j < strlen(buffer); j++)
    {
        strcpy(tempPrintArray, printArray[j]);
        write(fileDescOut, tempPrintArray, strlen(tempPrintArray));
    }

    free(buffer);
    free(printArray);
}
