/*Program written by Tiffani Shilts Winter 2020. This program is c99 compliant.
  Twist: This program accepts user input via argc and argv. User is allowed to provide: -i input preference (either
  stdin or file), -o output preference (either stdout or file), and -b the number with which to divide the input
  string by in order to parse it. User provides a string of characters through preferred method. Using the default
  or specified block size, the string is parsed into blocks of letters which are then reversed and output to the
  users preferred method. Default options generated by the program if the user does not specify are: stdin for input,
  stdout for output, and a block size of 10. Block size must be less than 1,000. Program uses only syscalls for all
  user input and output.
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

int main (int argc, char *argv[])
{
    // creating flag string variables for strcmp
    char inputFile[] = "-i";
    char outputFile[] = "-o";
    char blockNum[] = "-b";
    // buffer for read
    char *buffer = (char*)calloc(10001, sizeof(char));
    //comparison for fd number
    char comparisonStringIn[] = "stdin";
    char comparisonStringOut[] = "stdout";
    //fd in & out
    int fileDescIn;
    int fileDescOut;
    // number of bytes read in
    int numBytes;
    // number of string blocks aka arrays
    int numBlocks;
    // indexing using variable declared outside of loop
    int bufferArrayIndex;
    // checking for each array length in case of partial block filling
    int arrayLength;
    // temp character for array swap algorithm
    char temp;
    // for changing last index in case of partial block filling
    int lastIndex;

    // initialize default

    char* i = malloc(sizeof(char) * 1001);
    if (!i)
    {
        write(STDERR_FILENO, "Could not create Input File...exiting\n", 39);
        exit(1);
    }
    i = "stdin";

    char* o = malloc(sizeof(char) * 1001);
    if (!o)
    {
        write(STDERR_FILENO, "Could not create Output File...exiting\n", 40);
        exit(1);
    }
    o = "stdout";

    int b = 10;

    // replacing arguments with flags found in argv array

    for(int j = 0; j < argc; j++)
    {
        if(strcmp(inputFile, argv[j]) == 0)
        {
            i = argv[j+1];
        }
        else if(strcmp(outputFile, argv[j]) == 0)
        {
            o = argv[j+1];
        }
        else if(strcmp(blockNum, argv[j]) == 0)
        {
            b = atoi(argv[j+1]);
        }
    }

    // error checking block size
    if(b > 999)
    {
        write(STDERR_FILENO, "Block size is too large...exiting\n", 35);
        exit(1);
    }

    // file has been entered by user
    if((strcmp(comparisonStringIn, i)) != 0)
    {
        fileDescIn = open(i, O_RDONLY);

        if (fileDescIn < 0)
        {
            write(STDERR_FILENO, "Could not open input file...exiting\n", 37);
            exit(1);
        }
    }

    // if user requests no file entry or does not specify
    if((strcmp(comparisonStringIn, i)) == 0)
    {
        fileDescIn = 0;     //STDIN
    }

    // file has been entered by user
    if((strcmp(comparisonStringOut, o)) != 0)
    {
        fileDescOut = open(o, O_WRONLY);

        if (fileDescOut < 0)
        {
            write(STDERR_FILENO, "Could not open output file...exiting\n", 38);
            exit(1);
        }
    }

    // if user requests no file entry or does not specify
    if((strcmp(comparisonStringOut, o)) == 0)
    {
        fileDescOut = 1;        //STDOUT
    }

    // encouragement
    if (fileDescIn != 0)
    {
        write(1, "Success! Reading file...\n", 24);
    }

    // user provides string of characters to reverse
    if(fileDescIn == 0)
    {
        write(1, "Please enter a string of letters. Press ENTER when finished.\n", 62);
    }

    // read input and store in buffer
    while((numBytes = read(fileDescIn, buffer, 10000)) > 0)
        close(fileDescIn);

    // append null terminator
    buffer[strlen(buffer) - 2] = '\0';

    // number of arrays to create
    numBlocks = strlen(buffer)/b;

    if (numBlocks == 0)
    {
        numBlocks = 1;
    }

    if((strlen(buffer) % b != 0) && (numBlocks != 1))
    {
        numBlocks += 1;
    }

    // malloc for number of arrays because it won't change. calloc for arrays because one might not be full
    char **userInput = malloc(numBlocks * sizeof(char*));
    if(!userInput)
    {
        write(STDERR_FILENO, "Could not create pointer array...exiting\n", 40);
        exit(1);
    }
    for(int j = 0; j < numBlocks; j++)
    {
        userInput[j] = (char*) calloc((b + 1), sizeof(char));
        if(!userInput[j])
        {
        write(STDERR_FILENO, "Could not create block arrays...exiting\n", 41);
        exit(1);
        }
    }

    // filling arrays with user input
    bufferArrayIndex = 0;
    while((buffer[bufferArrayIndex]) != '\0')
    {
        for(int j = 0; j < numBlocks; j++)
        {
            for(int k = 0; k < b; k++)
            {
                userInput[j][k] = buffer[bufferArrayIndex++];
            }

        }
    }

    // reversing blocks
    for(int j = 0; j < numBlocks; j++)
    {
        arrayLength = strlen(userInput[j]);
        lastIndex = arrayLength - 1;
        for(int k = 0; k < lastIndex; k++, lastIndex--)
        {
            temp = userInput[j][k];
            userInput[j][k] = userInput[j][lastIndex];
            userInput[j][lastIndex] = temp;
        }
    }

    //printing to out destination
    char tempPrintArray[b+1];
    for(int j = 0; j < numBlocks; j++)
    {
        strcpy(tempPrintArray, userInput[j]);
        write(fileDescOut, tempPrintArray, strlen(tempPrintArray));
    }
    free(buffer);
    free(i);
    free(o);
    free(userInput);
}

